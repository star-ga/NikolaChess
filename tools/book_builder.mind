// Opening Book Builder - Pure Mind Implementation
// Builds opening books from PGN databases

use std::fs;
use std::io;
use std::collections::HashMap;

const MIN_GAMES: u32 = 10;      // Minimum games for a position
const MAX_DEPTH: u32 = 30;      // Maximum ply depth
const MIN_WIN_RATE: f32 = 0.4;  // Minimum win rate to include

struct BookEntry {
    moves: HashMap<Move, MoveStats>,
    total_games: u32,
}

struct MoveStats {
    wins: u32,
    draws: u32,
    losses: u32,
    avg_elo: u32,
}

impl MoveStats {
    fn games(&self) -> u32 {
        self.wins + self.draws + self.losses
    }

    fn win_rate(&self) -> f32 {
        let total = self.games() as f32;
        if total == 0.0 { return 0.5; }
        (self.wins as f32 + self.draws as f32 * 0.5) / total
    }

    fn score(&self) -> f32 {
        // Combine win rate and game count
        self.win_rate() * (1.0 + (self.games() as f32).ln() / 10.0)
    }
}

struct BookBuilder {
    positions: HashMap<u64, BookEntry>,  // Zobrist hash -> entry
    games_processed: u64,
}

impl BookBuilder {
    fn new() -> Self {
        BookBuilder {
            positions: HashMap::new(),
            games_processed: 0,
        }
    }

    fn add_game(&mut self, moves: &[Move], result: f32, avg_elo: u32) {
        let mut board = Board::startpos();

        for (ply, mv) in moves.iter().enumerate() {
            if ply as u32 >= MAX_DEPTH {
                break;
            }

            let hash = board.zobrist_hash();
            let entry = self.positions.entry(hash).or_insert(BookEntry {
                moves: HashMap::new(),
                total_games: 0,
            });

            let stats = entry.moves.entry(*mv).or_insert(MoveStats {
                wins: 0, draws: 0, losses: 0, avg_elo: 0,
            });

            // Update stats based on side to move
            let our_result = if board.side_to_move() == Color::White {
                result
            } else {
                1.0 - result
            };

            if our_result > 0.75 {
                stats.wins += 1;
            } else if our_result < 0.25 {
                stats.losses += 1;
            } else {
                stats.draws += 1;
            }

            // Running average for Elo
            let n = stats.games();
            stats.avg_elo = ((stats.avg_elo as u64 * (n - 1) as u64 + avg_elo as u64) / n as u64) as u32;

            entry.total_games += 1;
            board.make_move(*mv);
        }

        self.games_processed += 1;
    }

    fn prune(&mut self) {
        // Remove positions with too few games
        self.positions.retain(|_, entry| entry.total_games >= MIN_GAMES);

        // Remove moves with poor win rates
        for entry in self.positions.values_mut() {
            entry.moves.retain(|_, stats| {
                stats.games() >= 5 && stats.win_rate() >= MIN_WIN_RATE
            });
        }

        // Remove empty positions
        self.positions.retain(|_, entry| !entry.moves.is_empty());
    }

    fn save(&self, path: str) {
        let mut file = fs::File::create(path).unwrap();

        // Header
        file.write_u32(0x424F4F4B);  // "BOOK" magic
        file.write_u32(2);            // Version
        file.write_u32(self.positions.len() as u32);

        // Positions
        for (hash, entry) in &self.positions {
            file.write_u64(*hash);
            file.write_u32(entry.moves.len() as u32);

            // Sort moves by score
            let mut moves: Vec<_> = entry.moves.iter().collect();
            moves.sort_by(|a, b| b.1.score().partial_cmp(&a.1.score()).unwrap());

            for (mv, stats) in moves {
                file.write_u16(mv.to_u16());
                file.write_u16(stats.wins as u16);
                file.write_u16(stats.draws as u16);
                file.write_u16(stats.losses as u16);
            }
        }

        println!("Saved {} positions to {}", self.positions.len(), path);
    }
}

pub fn build_from_pgn(pgn_paths: &[str], output_path: str, min_elo: u32) {
    println!("Building opening book");
    println!("Sources: {:?}", pgn_paths);
    println!("Output: {}", output_path);
    println!("Min Elo: {}", min_elo);

    let mut builder = BookBuilder::new();

    for path in pgn_paths {
        println!("Processing {}...", path);

        let file = fs::File::open(path).unwrap();
        let reader = io::BufReader::new(file);

        for game in PgnParser::new(reader) {
            let white_elo = game.header("WhiteElo").parse().unwrap_or(0);
            let black_elo = game.header("BlackElo").parse().unwrap_or(0);

            if white_elo < min_elo || black_elo < min_elo {
                continue;
            }

            let result = match game.header("Result") {
                "1-0" => 1.0f32,
                "0-1" => 0.0f32,
                "1/2-1/2" => 0.5f32,
                _ => continue,
            };

            let avg_elo = (white_elo + black_elo) / 2;
            let moves: Vec<Move> = game.moves().collect();

            builder.add_game(&moves, result, avg_elo);

            if builder.games_processed % 10000 == 0 {
                println!("  {} games processed", builder.games_processed);
            }
        }
    }

    println!("Pruning weak moves...");
    builder.prune();

    builder.save(output_path);
    println!("Done! {} games processed", builder.games_processed);
}

// Merge multiple books
pub fn merge_books(book_paths: &[str], output_path: str) {
    println!("Merging {} books", book_paths.len());

    let mut combined: HashMap<u64, BookEntry> = HashMap::new();

    for path in book_paths {
        let book = load_book(path);
        for (hash, entry) in book {
            let combined_entry = combined.entry(hash).or_insert(BookEntry {
                moves: HashMap::new(),
                total_games: 0,
            });

            for (mv, stats) in entry.moves {
                let combined_stats = combined_entry.moves.entry(mv).or_insert(MoveStats {
                    wins: 0, draws: 0, losses: 0, avg_elo: 0,
                });
                combined_stats.wins += stats.wins;
                combined_stats.draws += stats.draws;
                combined_stats.losses += stats.losses;
            }
            combined_entry.total_games += entry.total_games;
        }
    }

    // Save combined book
    let builder = BookBuilder { positions: combined, games_processed: 0 };
    builder.save(output_path);
}

fn load_book(path: str) -> HashMap<u64, BookEntry> {
    let data = fs::read(path).unwrap();
    let mut cursor = 0;

    let magic = read_u32(&data, &mut cursor);
    assert!(magic == 0x424F4F4B, "Invalid book magic");

    let version = read_u32(&data, &mut cursor);
    let count = read_u32(&data, &mut cursor);

    let mut positions = HashMap::new();
    for _ in 0..count {
        let hash = read_u64(&data, &mut cursor);
        let move_count = read_u32(&data, &mut cursor);

        let mut moves = HashMap::new();
        for _ in 0..move_count {
            let mv = Move::from_u16(read_u16(&data, &mut cursor));
            let stats = MoveStats {
                wins: read_u16(&data, &mut cursor) as u32,
                draws: read_u16(&data, &mut cursor) as u32,
                losses: read_u16(&data, &mut cursor) as u32,
                avg_elo: 0,
            };
            moves.insert(mv, stats);
        }

        positions.insert(hash, BookEntry { moves, total_games: 0 });
    }

    positions
}

pub fn main() {
    let args = std::env::args();

    if args.len() < 2 {
        println!("Usage:");
        println!("  book_builder build <output.book> <input1.pgn> [input2.pgn...] [--min-elo=2200]");
        println!("  book_builder merge <output.book> <book1.book> [book2.book...]");
        return;
    }

    match args[1].as_str() {
        "build" => {
            let output = args.get(2).expect("Output path required");
            let inputs: Vec<_> = args[3..].iter()
                .filter(|s| !s.starts_with("--"))
                .cloned()
                .collect();
            let min_elo = args.iter()
                .find(|s| s.starts_with("--min-elo="))
                .map(|s| s.split('=').nth(1).unwrap().parse().unwrap())
                .unwrap_or(2200);
            build_from_pgn(&inputs, output, min_elo);
        }
        "merge" => {
            let output = args.get(2).expect("Output path required");
            let inputs: Vec<_> = args[3..].iter().cloned().collect();
            merge_books(&inputs, output);
        }
        _ => println!("Unknown command: {}", args[1]),
    }
}
