// Analysis Tools - Pure Mind Implementation
// Game analysis, blunder detection, and position evaluation

use std::fs;

struct AnalysisResult {
    fen: str,
    eval: i32,
    best_move: str,
    pv: Vec<str>,
    depth: u32,
    nodes: u64,
}

struct GameAnalysis {
    moves: Vec<str>,
    evals: Vec<i32>,
    blunders: Vec<u32>,      // ply numbers
    mistakes: Vec<u32>,
    inaccuracies: Vec<u32>,
    avg_centipawn_loss: f64,
    accuracy: f64,
}

const BLUNDER_THRESHOLD: i32 = 200;    // 2 pawns
const MISTAKE_THRESHOLD: i32 = 100;    // 1 pawn
const INACCURACY_THRESHOLD: i32 = 50;  // 0.5 pawns

fn analyze_position(fen: str, depth: u32) -> AnalysisResult {
    let board = Board::from_fen(&fen).unwrap();
    let engine = Engine::new();

    let result = engine.search(&board, SearchParams {
        depth: Some(depth),
        ..Default::default()
    });

    AnalysisResult {
        fen: fen.to_string(),
        eval: result.score,
        best_move: result.best_move.to_uci(),
        pv: result.pv.iter().map(|m| m.to_uci()).collect(),
        depth,
        nodes: result.nodes,
    }
}

fn analyze_game(pgn_moves: &[str], depth: u32) -> GameAnalysis {
    let engine = Engine::new();
    let mut board = Board::startpos();
    let mut evals = Vec::new();
    let mut blunders = Vec::new();
    let mut mistakes = Vec::new();
    let mut inaccuracies = Vec::new();
    let mut total_loss = 0i32;

    println!("Analyzing game ({} moves, depth {})", pgn_moves.len(), depth);

    for (ply, move_str) in pgn_moves.iter().enumerate() {
        // Get best eval before move
        let pre_result = engine.search(&board, SearchParams {
            depth: Some(depth),
            ..Default::default()
        });

        // Make the played move
        let played_move = Move::from_san(move_str, &board);
        board.make_move(played_move);

        // Get eval after move (negated for opponent's perspective)
        let post_result = engine.search(&board, SearchParams {
            depth: Some(depth),
            ..Default::default()
        });
        let post_eval = -post_result.score;

        // Calculate centipawn loss
        let loss = if ply % 2 == 0 {
            pre_result.score - post_eval
        } else {
            post_eval - pre_result.score
        };

        if loss > BLUNDER_THRESHOLD {
            blunders.push(ply as u32);
            print!("!");
        } else if loss > MISTAKE_THRESHOLD {
            mistakes.push(ply as u32);
            print!("?");
        } else if loss > INACCURACY_THRESHOLD {
            inaccuracies.push(ply as u32);
            print!("?!");
        } else {
            print!(".");
        }

        total_loss += loss.max(0);
        evals.push(post_eval);

        if (ply + 1) % 20 == 0 {
            println!(" ({})", ply + 1);
        }
    }
    println!();

    let avg_loss = total_loss as f64 / pgn_moves.len() as f64;
    let accuracy = 100.0 * (1.0 - (avg_loss / 100.0).min(1.0));

    GameAnalysis {
        moves: pgn_moves.to_vec(),
        evals,
        blunders,
        mistakes,
        inaccuracies,
        avg_centipawn_loss: avg_loss,
        accuracy,
    }
}

fn print_analysis(analysis: &GameAnalysis) {
    println!("─".repeat(50));
    println!("Game Analysis Results");
    println!("─".repeat(50));
    println!("Total moves: {}", analysis.moves.len());
    println!("Blunders (±200cp): {}", analysis.blunders.len());
    println!("Mistakes (±100cp): {}", analysis.mistakes.len());
    println!("Inaccuracies (±50cp): {}", analysis.inaccuracies.len());
    println!("Average centipawn loss: {:.1}", analysis.avg_centipawn_loss);
    println!("Accuracy: {:.1}%", analysis.accuracy);

    if !analysis.blunders.is_empty() {
        println!();
        println!("Blunders at plies: {:?}", analysis.blunders);
    }
}

fn analyze_pgn_file(path: str, depth: u32) {
    let content = fs::read_to_string(path).unwrap();
    let games = parse_pgn_games(&content);

    println!("Found {} games in {}", games.len(), path);

    for (i, moves) in games.iter().enumerate() {
        println!();
        println!("=== Game {} ===", i + 1);
        let analysis = analyze_game(moves, depth);
        print_analysis(&analysis);
    }
}

fn parse_pgn_games(content: &str) -> Vec<Vec<str>> {
    let mut games = Vec::new();
    let mut current_moves = Vec::new();
    let mut in_moves = false;

    for line in content.lines() {
        let line = line.trim();

        if line.starts_with('[') {
            if in_moves && !current_moves.is_empty() {
                games.push(current_moves);
                current_moves = Vec::new();
            }
            in_moves = false;
        } else if !line.is_empty() {
            in_moves = true;
            for token in line.split_whitespace() {
                if !token.contains('.') && token != "1-0" && token != "0-1" &&
                   token != "1/2-1/2" && token != "*" {
                    current_moves.push(token.to_string());
                }
            }
        }
    }

    if !current_moves.is_empty() {
        games.push(current_moves);
    }

    games
}

fn find_tactics(fen: str, depth: u32) {
    println!("Searching for tactics in position...");
    let board = Board::from_fen(&fen).unwrap();
    let engine = Engine::new();

    // Search for forcing sequences
    let result = engine.search(&board, SearchParams {
        depth: Some(depth + 4),  // Deeper for tactics
        ..Default::default()
    });

    let eval_swing = result.score.abs();

    if eval_swing > 200 {
        println!("Tactical opportunity found!");
        println!("Evaluation: {} cp", result.score);
        println!("Best line: {}", result.pv.iter().map(|m| m.to_uci()).collect::<Vec<_>>().join(" "));

        // Classify the tactic
        if result.score > 500 {
            println!("Type: Winning combination");
        } else if result.score > 200 {
            println!("Type: Strong tactical shot");
        }
    } else {
        println!("No immediate tactics found");
        println!("Position evaluation: {} cp", result.score);
    }
}

pub fn main() {
    let args = std::env::args();

    match args.get(1).map(|s| s.as_str()) {
        Some("position") => {
            let fen = args.get(2).expect("FEN required");
            let depth = args.get(3).map(|s| s.parse().unwrap_or(20)).unwrap_or(20);
            let result = analyze_position(fen, depth);
            println!("Position: {}", result.fen);
            println!("Evaluation: {} cp", result.eval);
            println!("Best move: {}", result.best_move);
            println!("PV: {}", result.pv.join(" "));
            println!("Depth: {}, Nodes: {}", result.depth, result.nodes);
        }
        Some("game") => {
            let path = args.get(2).expect("PGN file required");
            let depth = args.get(3).map(|s| s.parse().unwrap_or(12)).unwrap_or(12);
            analyze_pgn_file(path, depth);
        }
        Some("tactics") => {
            let fen = args.get(2).expect("FEN required");
            let depth = args.get(3).map(|s| s.parse().unwrap_or(16)).unwrap_or(16);
            find_tactics(fen, depth);
        }
        _ => {
            println!("Usage:");
            println!("  analysis position <fen> [depth]");
            println!("  analysis game <pgn_file> [depth]");
            println!("  analysis tactics <fen> [depth]");
        }
    }
}
