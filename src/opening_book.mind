// NikolaChess - Opening Book
// Copyright (c) 2026 STARGA, Inc. All rights reserved.
// PROPRIETARY AND CONFIDENTIAL
// Pre-computed draw lines from known openings
// Focus: Berlin, Petroff, Exchange Slav, Symmetrical English

import std.tensor;
import std.io;

// ============================================================================
// OPENING BOOK STRUCTURE
// ============================================================================

struct BookEntry {
    hash: u64,
    moves: Vec<BookMove>,
    depth: i32,           // How deep into the line
}

struct BookMove {
    move_data: Move,
    draw_prob: f32,       // Verified draw probability
    frequency: i32,       // How often played in master games
    source: str,          // "gm_games", "engine", "tablebase"
}

struct OpeningBook {
    entries: HashMap<u64, BookEntry>,
    max_depth: i32,
}

// ============================================================================
// BOOK CREATION
// ============================================================================

fn create_opening_book() -> OpeningBook {
    let book = OpeningBook {
        entries: HashMap.new(),
        max_depth: 30,  // Extend to 30 moves
    };

    // Add known drawish openings
    add_berlin_defense(&mut book);
    add_petroff_defense(&mut book);
    add_exchange_slav(&mut book);
    add_symmetrical_english(&mut book);
    add_qgd_exchange(&mut book);
    add_four_knights(&mut book);

    return book;
}

// ============================================================================
// DRAWISH OPENINGS
// ============================================================================

fn add_berlin_defense(book: &mut OpeningBook) {
    // Berlin Defense (Ruy Lopez) - The "Berlin Wall"
    // Known for extremely drawish endgame
    // 1.e4 e5 2.Nf3 Nc6 3.Bb5 Nf6 4.O-O Nxe4 5.d4 Nd6 6.Bxc6 dxc6 7.dxe5 Nf5 8.Qxd8+ Kxd8
    let lines = [
        ("e2e4", 0.95),  // 1.e4
        ("e7e5", 0.95),  // 1...e5
        ("g1f3", 0.96),  // 2.Nf3
        ("b8c6", 0.96),  // 2...Nc6
        ("f1b5", 0.97),  // 3.Bb5 (Ruy Lopez)
        ("g8f6", 0.98),  // 3...Nf6 (Berlin Defense!)
        ("e1g1", 0.98),  // 4.O-O
        ("f6e4", 0.99),  // 4...Nxe4
        ("d2d4", 0.99),  // 5.d4
        ("e4d6", 0.99),  // 5...Nd6
        ("b5c6", 0.99),  // 6.Bxc6
        ("d7c6", 0.99),  // 6...dxc6
        ("d4e5", 0.99),  // 7.dxe5
        ("d6f5", 0.99),  // 7...Nf5
        ("d1d8", 1.00),  // 8.Qxd8+ - Berlin Endgame!
        ("e8d8", 1.00),  // 8...Kxd8
    ];

    add_line_to_book(book, &lines, "berlin");
}

fn add_petroff_defense(book: &mut OpeningBook) {
    // Petroff Defense - Symmetrical and drawish
    // 1.e4 e5 2.Nf3 Nf6 3.Nxe5 d6 4.Nf3 Nxe4 5.d4 d5
    let lines = [
        ("e2e4", 0.95),
        ("e7e5", 0.95),
        ("g1f3", 0.96),
        ("g8f6", 0.97),  // Petroff!
        ("f3e5", 0.97),  // 3.Nxe5
        ("d7d6", 0.98),
        ("e5f3", 0.98),
        ("f6e4", 0.98),
        ("d2d4", 0.99),
        ("d6d5", 0.99),  // Symmetric pawn structure
    ];

    add_line_to_book(book, &lines, "petroff");
}

fn add_exchange_slav(book: &mut OpeningBook) {
    // Exchange Slav - Symmetric pawns, drawish
    // 1.d4 d5 2.c4 c6 3.cxd5 cxd5
    let lines = [
        ("d2d4", 0.94),
        ("d7d5", 0.94),
        ("c2c4", 0.95),  // Queen's Gambit
        ("c7c6", 0.96),  // Slav
        ("c4d5", 0.98),  // Exchange Variation!
        ("c6d5", 0.99),  // Symmetric
    ];

    add_line_to_book(book, &lines, "exchange_slav");
}

fn add_symmetrical_english(book: &mut OpeningBook) {
    // Symmetrical English - Both sides mirror
    // 1.c4 c5 2.Nc3 Nc6 3.g3 g6 4.Bg2 Bg7
    let lines = [
        ("c2c4", 0.93),
        ("c7c5", 0.94),  // Symmetrical!
        ("b1c3", 0.95),
        ("b8c6", 0.96),
        ("g2g3", 0.96),
        ("g7g6", 0.97),
        ("f1g2", 0.97),
        ("f8g7", 0.98),
        ("g1f3", 0.98),
        ("g8f6", 0.99),  // Full symmetry
    ];

    add_line_to_book(book, &lines, "symmetrical_english");
}

fn add_qgd_exchange(book: &mut OpeningBook) {
    // QGD Exchange Variation - Minority attack, often drawish
    // 1.d4 d5 2.c4 e6 3.Nc3 Nf6 4.cxd5 exd5
    let lines = [
        ("d2d4", 0.94),
        ("d7d5", 0.94),
        ("c2c4", 0.95),
        ("e7e6", 0.95),  // QGD
        ("b1c3", 0.96),
        ("g8f6", 0.96),
        ("c4d5", 0.97),  // Exchange Variation
        ("e6d5", 0.98),  // Symmetric center
        ("c1g5", 0.98),
        ("f8e7", 0.98),
        ("e2e3", 0.99),
        ("e8g8", 0.99),
    ];

    add_line_to_book(book, &lines, "qgd_exchange");
}

fn add_four_knights(book: &mut OpeningBook) {
    // Four Knights - Very symmetrical
    // 1.e4 e5 2.Nf3 Nc6 3.Nc3 Nf6 4.Bb5 Bb4
    let lines = [
        ("e2e4", 0.95),
        ("e7e5", 0.95),
        ("g1f3", 0.96),
        ("b8c6", 0.96),
        ("b1c3", 0.97),  // Four Knights!
        ("g8f6", 0.97),
        ("f1b5", 0.98),
        ("f8b4", 0.99),  // Spanish Four Knights
    ];

    add_line_to_book(book, &lines, "four_knights");
}

// ============================================================================
// BOOK UTILITIES
// ============================================================================

fn add_line_to_book(book: &mut OpeningBook, moves: &[(str, f32)], source: str) {
    let mut board = starting_position();  // FIX: Made mutable

    for (i, (move_str, draw_prob)) in moves.iter().enumerate() {
        let m = uci_to_move(*move_str, board);
        let hash = board.hash;

        // Add or update entry
        if let Some(entry) = book.entries.get_mut(hash) {
            // Check if move already exists
            let mut found = false;  // FIX: Made mutable
            for bm in entry.moves.iter_mut() {
                if bm.move_data.data == m.data {
                    bm.frequency += 1;
                    bm.draw_prob = max(bm.draw_prob, *draw_prob);
                    found = true;
                    break;
                }
            }

            if !found {
                entry.moves.push(BookMove {
                    move_data: m,
                    draw_prob: *draw_prob,
                    frequency: 1,
                    source: source.to_string(),
                });
            }
        } else {
            book.entries.insert(hash, BookEntry {
                hash: hash,
                moves: vec![BookMove {
                    move_data: m,
                    draw_prob: *draw_prob,
                    frequency: 1,
                    source: source.to_string(),
                }],
                depth: i as i32,
            });
        }

        // Make move for next position
        board = make_move(board, m);
    }
}

fn uci_to_move(uci: str, board: Board) -> Move {
    let from_file = (uci.chars()[0] as i32) - ('a' as i32);
    let from_rank = (uci.chars()[1] as i32) - ('1' as i32);
    let to_file = (uci.chars()[2] as i32) - ('a' as i32);
    let to_rank = (uci.chars()[3] as i32) - ('1' as i32);

    let from = from_rank * 8 + from_file;
    let to = to_rank * 8 + to_file;

    // Find piece on from square
    let mut piece = 0;  // FIX: Made mutable
    for p in 0..12 {
        if (board.pieces[p] & (1 << from)) != 0 {
            piece = p;
            break;
        }
    }

    // Check for capture
    let mut capture = 0;  // FIX: Made mutable
    for p in 0..12 {
        if (board.pieces[p] & (1 << to)) != 0 {
            capture = p;
            break;
        }
    }

    // Check for promotion
    let mut promo = 0;  // FIX: Made mutable
    if uci.len() > 4 {
        let promo_char = uci.chars()[4];
        promo = match promo_char {
            'q' => QUEEN + (piece / 6) * 6,
            'r' => ROOK + (piece / 6) * 6,
            'b' => BISHOP + (piece / 6) * 6,
            'n' => KNIGHT + (piece / 6) * 6,
            _ => 0,
        };
    }

    return create_move(from, to, piece, capture, promo, 0);
}

// ============================================================================
// BOOK PROBING
// ============================================================================

fn probe(book: &OpeningBook, board: Board) -> Option<Move> {
    let hash = board.hash;

    if let Some(entry) = book.entries.get(hash) {
        if entry.moves.is_empty() {
            return None;
        }

        // Find move with highest draw probability
        // (All moves in book should have draw_prob >= 0.95)
        let mut best_move = entry.moves[0].move_data;  // FIX: Made mutable
        let mut best_prob = entry.moves[0].draw_prob;  // FIX: Made mutable

        for bm in entry.moves.iter() {
            if bm.draw_prob > best_prob {
                best_prob = bm.draw_prob;
                best_move = bm.move_data;
            } else if bm.draw_prob == best_prob && bm.frequency > entry.moves[0].frequency {
                // Prefer more frequently played moves
                best_move = bm.move_data;
            }
        }

        return Some(best_move);
    }

    return None;
}

// ============================================================================
// BOOK I/O
// ============================================================================

fn save_book(book: &OpeningBook, path: str) {
    let file = io.open(path, "wb");

    // Write number of entries
    file.write_u32(book.entries.len() as u32);

    for (hash, entry) in book.entries.iter() {
        file.write_u64(*hash);
        file.write_u32(entry.moves.len() as u32);
        file.write_i32(entry.depth);

        for bm in entry.moves.iter() {
            file.write_u32(bm.move_data.data);
            file.write_f32(bm.draw_prob);
            file.write_i32(bm.frequency);
        }
    }

    file.close();
}

fn load_book(path: str) -> OpeningBook {
    let book = OpeningBook {
        entries: HashMap.new(),
        max_depth: 30,
    };

    if !io.exists(path) {
        return book;
    }

    let file = io.open(path, "rb");

    let num_entries = file.read_u32();

    for _ in 0..num_entries {
        let hash = file.read_u64();
        let num_moves = file.read_u32();
        let depth = file.read_i32();

        let moves = Vec.new();
        for _ in 0..num_moves {
            let move_data = Move { data: file.read_u32() };
            let draw_prob = file.read_f32();
            let frequency = file.read_i32();

            moves.push(BookMove {
                move_data: move_data,
                draw_prob: draw_prob,
                frequency: frequency,
                source: "loaded".to_string(),
            });
        }

        book.entries.insert(hash, BookEntry {
            hash: hash,
            moves: moves,
            depth: depth,
        });
    }

    file.close();
    return book;
}

// ============================================================================
// BOOK STATISTICS
// ============================================================================

fn book_stats(book: &OpeningBook) -> str {
    let total_positions = book.entries.len();
    let mut total_moves = 0;       // FIX: Made mutable
    let mut avg_draw_prob = 0.0;   // FIX: Made mutable

    for (_, entry) in book.entries.iter() {
        total_moves += entry.moves.len();
        for bm in entry.moves.iter() {
            avg_draw_prob += bm.draw_prob;
        }
    }

    if total_moves > 0 {
        avg_draw_prob /= total_moves as f32;
    }

    return format!(
        "Book Stats:\n  Positions: {}\n  Total moves: {}\n  Avg draw prob: {:.3}",
        total_positions, total_moves, avg_draw_prob
    );
}
