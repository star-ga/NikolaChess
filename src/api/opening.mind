// NikolaChess - Opening Book API
// Copyright (c) 2026 STARGA, Inc. All rights reserved.
// PROPRIETARY AND CONFIDENTIAL
//
// Complete opening book support:
// - Polyglot (.bin) - Standard format
// - CTG (.ctg) - ChessBase format
// - ABK (.abk) - Arena format
// - Lichess Explorer API
// - ChessDB Opening API
// - Masters Database API

import std.io;
import std.mem;

// ============================================================================
// BOOK FORMATS
// ============================================================================

enum BookFormat {
    Polyglot,      // .bin - Universal format
    CTG,           // .ctg/.ctb/.cto - ChessBase
    ABK,           // .abk - Arena Book
    BIN,           // Custom binary
}

// ============================================================================
// BOOK MOVE
// ============================================================================

struct BookMove {
    mv: Move,
    weight: i32,           // Priority/frequency
    learn: i32,            // Learning weight (if supported)
    win: i64,              // Win count
    draw: i64,             // Draw count
    loss: i64,             // Loss count
    avg_elo: i32,          // Average player ELO
    perf: f32,             // Performance rating
}

fn calc_win_rate(bm: &BookMove) -> f32 {
    let total = bm.win + bm.draw + bm.loss;
    if total == 0 {
        return 0.5;
    }
    return (bm.win as f32 + bm.draw as f32 * 0.5) / total as f32;
}

// ============================================================================
// POLYGLOT BOOK FORMAT
// ============================================================================

// Polyglot entry: 16 bytes
// - key: u64 (Zobrist hash)
// - move: u16 (encoded move)
// - weight: u16
// - learn: u32

struct PolyglotEntry {
    key: u64,
    move_data: u16,
    weight: u16,
    learn: u32,
}

struct PolyglotBook {
    path: str,
    data: Vec<u8>,
    num_entries: usize,
    loaded: bool,
}

fn load_polyglot(path: &str) -> Option<PolyglotBook> {
    if !io.exists(path) {
        return None;
    }

    let data = io.read_file_binary(path)?;
    let num_entries = data.len() / 16;

    println!("Polyglot: Loaded {} entries from {}", num_entries, path);

    return Some(PolyglotBook {
        path: path.to_string(),
        data: data,
        num_entries: num_entries,
        loaded: true,
    });
}

fn probe_polyglot(book: &PolyglotBook, board: Board) -> Vec<BookMove> {
    let key = polyglot_hash(board);
    let mut moves = Vec::new();

    // Binary search for first entry with matching key
    let mut lo = 0;
    let mut hi = book.num_entries;

    while lo < hi {
        let mid = (lo + hi) / 2;
        let entry_key = read_polyglot_key(&book.data, mid);

        if entry_key < key {
            lo = mid + 1;
        } else {
            hi = mid;
        }
    }

    // Read all entries with matching key
    while lo < book.num_entries {
        let entry = read_polyglot_entry(&book.data, lo);
        if entry.key != key {
            break;
        }

        let mv = decode_polyglot_move(entry.move_data, board);
        if mv.is_some() {
            moves.push(BookMove {
                mv: mv.unwrap(),
                weight: entry.weight as i32,
                learn: entry.learn as i32,
                win: 0,
                draw: 0,
                loss: 0,
                avg_elo: 0,
                perf: 0.0,
            });
        }

        lo += 1;
    }

    return moves;
}

fn read_polyglot_key(data: &[u8], index: usize) -> u64 {
    let offset = index * 16;
    let mut key: u64 = 0;
    for i in 0..8 {
        key = (key << 8) | data[offset + i] as u64;
    }
    return key;
}

fn read_polyglot_entry(data: &[u8], index: usize) -> PolyglotEntry {
    let offset = index * 16;

    let mut key: u64 = 0;
    for i in 0..8 {
        key = (key << 8) | data[offset + i] as u64;
    }

    let move_data = ((data[offset + 8] as u16) << 8) | data[offset + 9] as u16;
    let weight = ((data[offset + 10] as u16) << 8) | data[offset + 11] as u16;
    let learn = ((data[offset + 12] as u32) << 24) |
                ((data[offset + 13] as u32) << 16) |
                ((data[offset + 14] as u32) << 8) |
                data[offset + 15] as u32;

    return PolyglotEntry {
        key: key,
        move_data: move_data,
        weight: weight,
        learn: learn,
    };
}

fn decode_polyglot_move(data: u16, board: Board) -> Option<Move> {
    // Polyglot move encoding:
    // bits 0-5: to file
    // bits 6-8: to rank
    // bits 9-11: from file
    // bits 12-14: from rank
    // bits 15-16: promotion piece (0=none, 1=knight, 2=bishop, 3=rook, 4=queen)

    let to_file = (data & 0x7) as i32;
    let to_rank = ((data >> 3) & 0x7) as i32;
    let from_file = ((data >> 6) & 0x7) as i32;
    let from_rank = ((data >> 9) & 0x7) as i32;
    let promo = ((data >> 12) & 0x7) as i32;

    let from = from_rank * 8 + from_file;
    let to = to_rank * 8 + to_file;

    // Handle castling (king moves 2 squares)
    let piece = board.piece_on(from)?;

    let mut flags = 0;
    if piece == KING && abs(to_file - from_file) == 2 {
        flags = if to_file > from_file { FLAG_CASTLE_K } else { FLAG_CASTLE_Q };
    }

    let promotion = match promo {
        1 => KNIGHT,
        2 => BISHOP,
        3 => ROOK,
        4 => QUEEN,
        _ => 0,
    };

    return Some(Move {
        from: from,
        to: to,
        piece: piece,
        capture: board.piece_on(to).unwrap_or(0),
        promotion: promotion,
        flags: flags,
        data: 0,
    });
}

// Polyglot Zobrist hashing (different from our internal hash)
fn polyglot_hash(board: Board) -> u64 {
    let mut hash: u64 = 0;

    // Piece placement
    for sq in 0..64 {
        if let Some(piece) = board.piece_on(sq) {
            let poly_piece = piece_to_polyglot(piece);
            hash ^= POLYGLOT_PIECE_KEYS[poly_piece * 64 + sq];
        }
    }

    // Castling
    if board.castling[0] { hash ^= POLYGLOT_CASTLE_KEYS[0]; }  // White kingside
    if board.castling[1] { hash ^= POLYGLOT_CASTLE_KEYS[1]; }  // White queenside
    if board.castling[2] { hash ^= POLYGLOT_CASTLE_KEYS[2]; }  // Black kingside
    if board.castling[3] { hash ^= POLYGLOT_CASTLE_KEYS[3]; }  // Black queenside

    // En passant
    if board.ep_square >= 0 {
        let ep_file = board.ep_square % 8;
        hash ^= POLYGLOT_EP_KEYS[ep_file as usize];
    }

    // Side to move
    if board.side_to_move == 0 {  // White
        hash ^= POLYGLOT_TURN_KEY;
    }

    return hash;
}

fn piece_to_polyglot(piece: i32) -> usize {
    // Polyglot piece order: bp, wp, bn, wn, bb, wb, br, wr, bq, wq, bk, wk
    let piece_type = piece % 6;
    let color = piece / 6;  // 0 = white, 1 = black

    let base = match piece_type {
        PAWN => 0,
        KNIGHT => 2,
        BISHOP => 4,
        ROOK => 6,
        QUEEN => 8,
        KING => 10,
        _ => 0,
    };

    return base + (1 - color) as usize;  // Polyglot: black=0, white=1
}

// Polyglot random keys (truncated for brevity - full keys in separate file)
static POLYGLOT_PIECE_KEYS: [u64; 768] = [/* ... */];
static POLYGLOT_CASTLE_KEYS: [u64; 4] = [/* ... */];
static POLYGLOT_EP_KEYS: [u64; 8] = [/* ... */];
static POLYGLOT_TURN_KEY: u64 = 0xF8D626AAAF278509;

// ============================================================================
// CTG BOOK FORMAT (ChessBase)
// ============================================================================

struct CTGBook {
    ctg_path: str,     // .ctg - game data
    ctb_path: str,     // .ctb - page data
    cto_path: str,     // .cto - index
    loaded: bool,
}

fn load_ctg(base_path: &str) -> Option<CTGBook> {
    let ctg_path = format!("{}.ctg", base_path);
    let ctb_path = format!("{}.ctb", base_path);
    let cto_path = format!("{}.cto", base_path);

    if !io.exists(&ctg_path) || !io.exists(&ctb_path) || !io.exists(&cto_path) {
        return None;
    }

    println!("CTG: Loaded book from {}", base_path);

    return Some(CTGBook {
        ctg_path: ctg_path,
        ctb_path: ctb_path,
        cto_path: cto_path,
        loaded: true,
    });
}

fn probe_ctg(book: &CTGBook, board: Board) -> Vec<BookMove> {
    // CTG format is proprietary and complex
    // Implementation would require reverse-engineering the format
    // For now, return empty - would need full CTG parser
    return Vec::new();
}

// ============================================================================
// ABK BOOK FORMAT (Arena)
// ============================================================================

struct ABKBook {
    path: str,
    data: Vec<u8>,
    loaded: bool,
}

fn load_abk(path: &str) -> Option<ABKBook> {
    if !io.exists(path) {
        return None;
    }

    let data = io.read_file_binary(path)?;
    println!("ABK: Loaded book from {}", path);

    return Some(ABKBook {
        path: path.to_string(),
        data: data,
        loaded: true,
    });
}

fn probe_abk(book: &ABKBook, board: Board) -> Vec<BookMove> {
    // ABK format parsing
    // Header: 8 bytes
    // Each entry: variable length

    // Simplified implementation - would need full ABK parser
    return Vec::new();
}

// ============================================================================
// LICHESS EXPLORER API
// ============================================================================

fn probe_lichess_explorer(
    http: &HttpClientPool,
    fen: &str,
    timeout_ms: i64
) -> Option<Vec<BookMove>> {
    // Options: masters, lichess, player
    let url = format!(
        "https://explorer.lichess.ovh/lichess?fen={}&ratings=2200,2500&speeds=classical,rapid",
        url_encode(fen)
    );

    let response = http.get(&url).timeout(timeout_ms).send().ok()?;
    if response.status != 200 {
        return None;
    }

    let json = response.json().ok()?;
    let moves_arr = json["moves"].as_array()?;

    let mut moves = Vec::new();
    for mv_json in moves_arr {
        let uci = mv_json["uci"].as_str()?;
        let mv = parse_uci_move(uci)?;

        let white = mv_json["white"].as_i64().unwrap_or(0);
        let draws = mv_json["draws"].as_i64().unwrap_or(0);
        let black = mv_json["black"].as_i64().unwrap_or(0);
        let total = white + draws + black;

        moves.push(BookMove {
            mv: mv,
            weight: total as i32,
            learn: 0,
            win: white,
            draw: draws,
            loss: black,
            avg_elo: mv_json["averageRating"].as_i64().unwrap_or(0) as i32,
            perf: if total > 0 {
                (white as f32 + draws as f32 * 0.5) / total as f32
            } else {
                0.5
            },
        });
    }

    return Some(moves);
}

fn probe_lichess_masters(
    http: &HttpClientPool,
    fen: &str,
    timeout_ms: i64
) -> Option<Vec<BookMove>> {
    let url = format!(
        "https://explorer.lichess.ovh/masters?fen={}",
        url_encode(fen)
    );

    let response = http.get(&url).timeout(timeout_ms).send().ok()?;
    if response.status != 200 {
        return None;
    }

    let json = response.json().ok()?;
    let moves_arr = json["moves"].as_array()?;

    let mut moves = Vec::new();
    for mv_json in moves_arr {
        let uci = mv_json["uci"].as_str()?;
        let mv = parse_uci_move(uci)?;

        let white = mv_json["white"].as_i64().unwrap_or(0);
        let draws = mv_json["draws"].as_i64().unwrap_or(0);
        let black = mv_json["black"].as_i64().unwrap_or(0);
        let total = white + draws + black;

        moves.push(BookMove {
            mv: mv,
            weight: total as i32,
            learn: 0,
            win: white,
            draw: draws,
            loss: black,
            avg_elo: mv_json["averageRating"].as_i64().unwrap_or(2500) as i32,
            perf: if total > 0 {
                (white as f32 + draws as f32 * 0.5) / total as f32
            } else {
                0.5
            },
        });
    }

    return Some(moves);
}

// ============================================================================
// CHESSDB OPENING API
// ============================================================================

fn probe_chessdb_book(
    http: &HttpClientPool,
    fen: &str,
    timeout_ms: i64
) -> Option<Vec<BookMove>> {
    let url = format!(
        "https://www.chessdb.cn/cdb.php?action=querypv&board={}",
        url_encode(fen)
    );

    let response = http.get(&url).timeout(timeout_ms).send().ok()?;
    if response.status != 200 {
        return None;
    }

    let text = response.text().ok()?;
    if text.starts_with("unknown") {
        return None;
    }

    // Parse response: "move1|move2|move3..."
    let parts: Vec<&str> = text.split('|').collect();
    let mut moves = Vec::new();

    for (i, part) in parts.iter().enumerate() {
        if let Some(mv) = parse_uci_move(part.trim()) {
            moves.push(BookMove {
                mv: mv,
                weight: (100 - i * 10) as i32,  // Decreasing weight
                learn: 0,
                win: 0,
                draw: 0,
                loss: 0,
                avg_elo: 0,
                perf: 0.0,
            });
        }
    }

    return Some(moves);
}

// ============================================================================
// UNIFIED OPENING BOOK
// ============================================================================

struct OpeningUnified {
    polyglot: Option<PolyglotBook>,
    ctg: Option<CTGBook>,
    abk: Option<ABKBook>,
    http: HttpClientPool,
    cache: LRUCache<u64, Vec<BookMove>>,
    stats: OpeningStats,
}

struct OpeningStats {
    polyglot_probes: i64,
    polyglot_hits: i64,
    ctg_probes: i64,
    ctg_hits: i64,
    abk_probes: i64,
    abk_hits: i64,
    lichess_probes: i64,
    lichess_hits: i64,
    chessdb_probes: i64,
    chessdb_hits: i64,
}

fn create_opening_unified(config: &APIConfig) -> OpeningUnified {
    let polyglot = if let Some(path) = &config.polyglot_path {
        load_polyglot(path)
    } else {
        None
    };

    let ctg = if let Some(path) = &config.ctg_path {
        load_ctg(path)
    } else {
        None
    };

    let abk = if let Some(path) = &config.abk_path {
        load_abk(path)
    } else {
        None
    };

    return OpeningUnified {
        polyglot: polyglot,
        ctg: ctg,
        abk: abk,
        http: HttpClientPool::new(4),
        cache: LRUCache::new(100_000),
        stats: OpeningStats::default(),
    };
}

fn probe_opening_unified(
    opening: &mut OpeningUnified,
    board: Board,
    config: &APIConfig
) -> Option<Vec<BookMove>> {
    let hash = board.hash;

    // Check cache
    if let Some(cached) = opening.cache.get(hash) {
        return Some(cached.clone());
    }

    let mut all_moves: Vec<BookMove> = Vec::new();

    // 1. Polyglot
    if let Some(ref book) = opening.polyglot {
        opening.stats.polyglot_probes += 1;
        let moves = probe_polyglot(book, board);
        if !moves.is_empty() {
            opening.stats.polyglot_hits += 1;
            all_moves.extend(moves);
        }
    }

    // 2. CTG
    if let Some(ref book) = opening.ctg {
        opening.stats.ctg_probes += 1;
        let moves = probe_ctg(book, board);
        if !moves.is_empty() {
            opening.stats.ctg_hits += 1;
            merge_book_moves(&mut all_moves, moves);
        }
    }

    // 3. ABK
    if let Some(ref book) = opening.abk {
        opening.stats.abk_probes += 1;
        let moves = probe_abk(book, board);
        if !moves.is_empty() {
            opening.stats.abk_hits += 1;
            merge_book_moves(&mut all_moves, moves);
        }
    }

    // 4. Lichess Explorer (if no local results)
    if all_moves.is_empty() && config.lichess_explorer_enabled {
        opening.stats.lichess_probes += 1;
        let fen = board_to_fen(board);
        if let Some(moves) = probe_lichess_explorer(&opening.http, &fen, config.remote_timeout_ms) {
            opening.stats.lichess_hits += 1;
            all_moves.extend(moves);
        }
    }

    // 5. ChessDB (if still no results)
    if all_moves.is_empty() && config.chessdb_book_enabled {
        opening.stats.chessdb_probes += 1;
        let fen = board_to_fen(board);
        if let Some(moves) = probe_chessdb_book(&opening.http, &fen, config.remote_timeout_ms) {
            opening.stats.chessdb_hits += 1;
            all_moves.extend(moves);
        }
    }

    if all_moves.is_empty() {
        return None;
    }

    // Sort by weight
    all_moves.sort_by(|a, b| b.weight.cmp(&a.weight));

    // Cache result
    opening.cache.insert(hash, all_moves.clone());

    return Some(all_moves);
}

fn merge_book_moves(target: &mut Vec<BookMove>, source: Vec<BookMove>) {
    for mv in source {
        let exists = target.iter_mut().find(|m| m.mv.data == mv.mv.data);
        if let Some(existing) = exists {
            // Merge statistics
            existing.win += mv.win;
            existing.draw += mv.draw;
            existing.loss += mv.loss;
            existing.weight = existing.weight.max(mv.weight);
        } else {
            target.push(mv);
        }
    }
}
